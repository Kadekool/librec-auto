from pathlib import Path
import hashlib
from librec_auto.util import SubPaths
from librec_auto.util.utils import force_path
from collections import OrderedDict

class Files:
    """
    This class encapsulates the file system for librec-auto.

    The files for librec-auto can be stored in a number of possible locations:
    - global location: determined by the install location of librec-auto
    - rules-specific location: determined by the location of a rules directory
    - user-specific location: associated with the user's home directory
    - experiment-specific location: in a directory associated with a specific experiment. See sub_paths.py for a class
      that handles the sub-experiment-specific files.

    These are the types of files that are managed:
    - configuration files (XML). Stores information about how experiments are configured.
    - properties files (key=value format). Generated from configuration files for input to librec
    - split files (UIR or UIRT format). Generated by separating input rules files into different test/training splits
    - experiment logs (csv files). Content is algorithm-specific. Generated by a run of an experiment

    NOTE: User and rules directories are currently unused.
    """

    _global_dir_path = None
    _sub_path_dict = None
    _config_dir_path = None
    _rules_dir_path = None
    #_res_dir_path = None
    _split_dir_path = None
    _jar_dir_path = None
    _post_dir_path = None

    _prop_file_name = None

#    _DEFAULT_GLOBAL_DIR_STR = inspect.getfile("librec_auto") # This needs to be tested.
    _DEFAULT_GLOBAL_DIR_STR = "."

    _DEFAULT_CONFIG_DIR_NAME = "conf"
    _DEFAULT_RULES_DIR_NAME = "rules"
    _DEFAULT_RES_DIR_NAME = "result"
    _DEFAULT_SPLIT_DIR_NAME = "split"
    _DEFAULT_JAR_DIR_NAME = "jar"
    _DEFAULT_POST_DIR_NAME = "post"
    _EXP_DIR_PATTERN = "exp{:05d}"

    _DEFAULT_PROP_FILE_NAME = "librec.properties"
    _DEFAULT_LA_JAR = "auto.jar"
    _DEFAULT_LR_JAR = "librec.jar"
    _DEFAULT_RULES_FILE = "rules/element-rules.xml"
    LOG_PATH = "../log/librec.log"

    # 2019-11-22 RB Do we use this anywhere?
    # _DEFAULT_CACHE_FILENAME = ".cache"

    def __init__(self):
        self._config_dir_path = Path(self._DEFAULT_CONFIG_DIR_NAME)
        self._rules_dir_path = Path(self._DEFAULT_RULES_DIR_NAME)
        #self._res_dir_path = Path(self._DEFAULT_RES_DIR_NAME)
        self._split_dir_path = Path(self._DEFAULT_SPLIT_DIR_NAME)
        self._jar_dir_path = Path(self._DEFAULT_JAR_DIR_NAME)
        self._post_dir_path = Path(self._DEFAULT_POST_DIR_NAME)
        self._sub_path_dict = OrderedDict()

        maybe_global_path = Path(Files._DEFAULT_GLOBAL_DIR_STR)
        if maybe_global_path.is_dir():
            self._global_dir_path = maybe_global_path
        # maybe_user_path = Path(Files._DEFAULT_USER_PATH_STR)
        # if maybe_user_path.is_dir():
        #     self._user_path = maybe_user_path

    def get_global_path(self): return self._global_path

    def get_jar_path(self): return self._jar_dir_path

    def get_exp_path(self): return self._exp_path

    def get_split_path(self): return self._split_dir_path

    def get_config_path(self): return self._exp_path / self._config_dir_path / self._config_file_name

    def get_post_path(self): return self._post_dir_path

    def set_global_path(self, path): self._global_path = Path(path)

    def set_config_dir_path(self, path): self._config_dir_path = Path(path)

    def set_exp_path(self, path): self._exp_path = Path(path)

    def set_config_file(self, filename): self._config_file_name = Path(filename)

    def get_rules_path (self):
        return self.get_global_path() / self._DEFAULT_RULES_FILE

    def get_classpath (self):
        return self.get_global_path() / self.get_jar_path() / self._DEFAULT_LA_JAR + ";" + \
               self.get_global_path() / self.get_jar_path() / self._DEFAULT_LR_JAR

    def get_sub_dir_path (self, count):
        sub_name = self._EXP_DIR_PATTERN.format(count)
        return self.get_exp_path / Path(sub_name)

    def detect_sub_paths (self):
        sub_count = 1
        while self.get_sub_dir_path(sub_count).exists():
            self._sub_path_dict[sub_count] = SubPaths(self.get_sub_dir_path(sub_count), create=False)
            sub_count += 1

    def create_sub_paths (self):
        sub_count = 1
        while self.get_sub_dir_path(sub_count).exists():
            self._sub_path_dict[sub_count] = SubPaths(self.get_sub_dir_path(sub_count), create=True)
            sub_count += 1

    def get_sub_count (self):
        if len(self._sub_path_dict) > 0:
            max(self._sub_path_dict.keys())
        else:
            0

    def get_sub_paths(self, count):
        if count in self._sub_path_dict:
            return self._sub_path_dict[count]
        else:
            return None

    def get_sub_paths_iterator(self):
        return self._sub_path_dict.values()

    @staticmethod
    def dir_hash(maybe_path):
        """
        Starting from a directory, gets all subdirectories, extracts the individual files and creates a hash value
        using the file name, size, and last modification date.

        Probably just modification date is enough.
        :param maybe_path:
        :return:
        """
        hasher = hashlib.sha1()
        path = force_path(maybe_path)
        full_listing = path.glob('**/*')
        files = [fl for fl in full_listing if fl.is_file()]
        for fl in files:
            fl_stat = fl.stat()
            fl_size = fl_stat.st_size
            fl_date = fl_stat.st_mtime
            fl_info = "{}-{}-{}".format(fl.name, fl_size, fl_date)
            fl_bytes = fl_info.encode('utf-8')
            hasher.update(fl_bytes)
        return hasher.hexdigest()
