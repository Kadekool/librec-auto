from collections import OrderedDict, defaultdict
from librec_auto.core.util import Files, utils, build_parent_path
from lxml import etree
import copy
import logging
import itertools
from pathlib import Path
from librec_auto.core.config_lib import ConfigLibCollection, ConfigLib


class ConfigCmd:
    """
    Loads the configuration file, identifies the parameter variations and creates separate configurations
    for all combinations.
    """

    _xml_input = None
    _var_tuples = None
    _target = None
    _libraries = None

    IGNOREABLE_ATTRIBUTES = ['@ref', '@src', '@name']

    def __init__(self, config_file, target):

        self._files = Files()
        self._target = target

        self._files.set_exp_path(target)
        self._files.set_config_file(config_file)

        self._xml_input = self.read_xml(self._files.get_config_path())

        self._var_data = defaultdict(list)

        self._var_params = []

        self._var_tuples = []

        self._libraries = ConfigLibCollection()

    def get_target(self):
        return self._target

    def get_var_data(self):
        return self._var_data

    def get_value_tuple(self, subexp_no):
        return self._value_tuples[subexp_no]

    def get_sub_exp_count(self):
        exp_count = len(self._value_tuples)
        if exp_count == 0:
            return 1
        else:
            return exp_count

    def get_files(self):
        return self._files

    def read_xml(self, path_str):
        path = self._files.get_config_path()
        if (path.exists()):
            xml_input = xml_load_from_path(path)
            return xml_input
        else:
            return None

    def _load_from_file(self, path):
        """
        Loads the configuration file in a dictionary

        This is the raw configuration. Prints a warning and returns None
        if the file can't be read.
        :param path: The file name
        :return: A dictionary with the XML rules
        """
        try:
            with path.open() as fd:
                txt = fd.read()
        except IOError as e:
            print ("Error reading ", path)
            print ("IO error({0}): {1}".format(e.errno, e.strerror))
            logging.error("Error reading %s. IO error: (%d) %s", path, e.errno, e.strerror)
            return None

        return utils.xml_load_from_text(txt)

    def ensure_experiments(self):
        exp_count = len(self._var_tuples)
        if exp_count == 0:
            exp_count = 1
        self.get_files().ensure_sub_paths(exp_count)


    # Process config takes the config file and produces a dictionary of the following form:
    # xpath-string => list of values
    # or xpath-string => (range-to, range-from) pair
    # Right now, we will assume the first
    def process_config(self):
        self._var_data = defaultdict(list)
        value_elems = self._xml_input.xpath('//value')
        parents = [elem.getparent() for elem in value_elems]
        parents = list(set(parents))
        for parent in parents:
            vals = [elem.text for elem in parent.iterchildren(tag='value')]
            parent_path = build_parent_path(parent)
            self._var_data[parent_path] = vals
        self._var_tuples = list(itertools.product(*self._var_data.values()))
        self.ensure_experiments()
        self.write_exp_configs()

    # Write versions of the config file in which the parameters with multiple values are replaced with
    # a single value
    def write_exp_configs(self):
        configs = list(zip(self.get_files().get_sub_paths_iterator(), iter(self._var_tuples)))

        for exp, tuple in configs:
            self.write_exp_config(exp, tuple)

    def write_exp_config(self, exp, tuple):
        new_xml = copy.deepcopy(self._xml_input)
        for parent_path, val in zip(self._var_data.keys(), iter(tuple)):
            var_elem = new_xml.xpath(parent_path)[0]
            var_elem.clear()
            var_elem.text = str(val)
        new_xml.append(etree.Comment('This configuration file was automatically generated by librec-auto. ' +
                        'Editing may produce unpredictable results and is not recommended.'))
        outpath = exp.get_path('conf') / Files.DEFAULT_CONFIG_FILENAME
        logging.info('Writing config file ' + str(outpath))
        new_xml.getroottree().write(outpath.absolute().as_posix(), pretty_print=True)

    def has_rerank(self):
        rerank_elems = self._xml_input.xpath('/librec-auto/rerank')
        return len(rerank_elems) > 0

    def has_post(self):
        post_elems = self._xml_input.xpath('/librec-auto/post')
        return len(post_elems) > 0

    def is_valid(self):
        return self._xml_input is not None

    def thread_count(self):
        thread_elems = self._xml_input.xpath('/librec-auto/thread-count')
        if len(thread_elems) == 0:
            return 1
        else:
            return int(thread_elems[0].text)

    def setup_libraries(self):
        if utils.safe_xml_path(self._xml_input, ['librec-auto', 'library']):
            lib_elems = utils.force_list(utils.extract_from_path(self._xml_input, ['librec-auto', 'library']))
            for lib in lib_elems:
                lib_path = self.extract_library_path(lib)
                lib = ConfigLib(lib_path)
                self._libraries.append(lib)

    def extract_library_path(self, lib_elem):
        file_name = lib_elem['#text'] if type(lib_elem) is OrderedDict else lib_elem
        file_path = Path(file_name)
        path_prefix = None
        if type(lib_elem) is OrderedDict:
            if '@src' in lib_elem:
                if 'system' == lib_elem['@src']:
                    path_prefix = self._files.get_lib_path()
                else:
                    print(f'librec-auto: WARNING Path source {lib_elem["@src"]} is unknown. Possible values are: system')
        else: # If library path is just as string without directory information, assume conf directory
            if file_path.parent == Path('.'):
                path_prefix = self._files.get_config_path().parent
        if path_prefix is None:
            return file_path
        else:
            return path_prefix / file_path

def read_config_file(config_file, target):
    config = ConfigCmd(config_file, target)
    if config.is_valid():
        config.process_config()
    return config

